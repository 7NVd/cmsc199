\section{Introduction}
 Pattern matching is an important concept in computer science due to its many technological applications such as DNA matching, voice recognition, face recognition, network security, and text processing.
\\
Pattern matching is finding one or all occurrences of a certain pattern $p$ of length $m$ in a text $t$ of length $n$. Pattern matching algorithms as is with all other algorithms base its performance by its time efficiency. The time efficiency of a pattern matching algorithm is based on its basic operation: comparison. A higher number of comparisons mean longer time efficiency. Thus, most pattern matching algorithms are concerned with minimizing the number of comparisons to get a better time efficiency.
\\
This paper is concerned with discussing and illustrating three pattern matching algorithms: brute force, Boyer-Moore, and Berry Ravindran. Furthermore, this paper also aims to elaborate on the developments made on each algorithm and how each development improved the time efficiency of the algorithm's search time.
\section{Definition of Terms}

\section{Brute Force}
The brute force or naive method compares each character in the pattern $p$ to each character in the text $t$. It compares $p$ to $t$ from left to right until it finds $p$ or a mismatch occurs or there is an insufficient number of characters left in $t$. 
\subsection{Algorithm}
The algorithm for the brute force method is given below:
\begin{lstlisting}
BruteForceStringMatch(T[0...n-1],P[0...m-1])
//Input: An array T[0...n-1] of n characters representing a text and an array P[0...m-1] of m characters representing a pattern
//Output: The index of the first character in the text that starts a matching substring or -1 if the search is unsuccessful
		for i = 0 to n-m do
			j = 0
			while j < m and P[j] = T[i+j] do
				j = j+1
			if j = m return i
		return -1 
\end{lstlisting} 
\subsection{Example}
hey paul can you put the example from our presentation?? thanks!
\subsection{Worst Case}    
The worst case occurs when the number of comparisons is maximized. From the algorithm above, the maximum number of comparisons made between each character from $p$ to the characters in text $t$ is $m$. This is attained when each character from $p$ is compared to each corresponding character in $t$. Furthermore, the maximum number of comparisons between $p$ and $t$ is $n-m+1$. This is attained due to the nature of the algorithm wherein it compares $p$ to $t$ at least once and shifting just once if a mismatch occurs. Thus, the maximum number of comparison is $(m)(n-m+1)$ which implies that the time complexity of the worst case is $\Theta(nm)$.
\section{Boyer-Moore}		%	Boyer Moore
The Boyer-Moore String Matching algorithm performs its match from right to left instead the usual left to right of its time. This right to left matching enabled Boyer-Moore algorithm to skip more characters than the other algorithms.

\subsection{Algorithm}
The Boyer-Moore searches using the following algorithm:
\begin{lstlisting}[mathescape=true]
		$stringlen \gets$ length of $string$.
		$i \gets patlen.$
$top$:	if $i > stringlen$ then return false
		$j \gets patlen$.
$loop$:	if $j=0$ then return $j+1$.
		if $string(i)=pat(j)$
			then
			$j \gets j-1$.
			$i \gets i-1$.
			goto $loop$.
			close;
		$i \gets i + max(\ delta_1(string(i)),\ delta_2(j)\ )$
\end{lstlisting}

With this algorithm, pattern $pat$ of length $patlen$ is searched in string $string$ of length $stringlen$.

\section{Berry Ravindran}		%	Berry Ravindran
Based on a plethora of algorithms that was brought about by Boyer-Moore Exact String Matching Algorithm, Berry and Ravindran designed an algorithm which does shifting considering the two consecutive characters to the right of the window.
\subsection{Algorithm}
\begin{enumerate}
\item Let $P$ be the pattern string to find. Let $T$ be the text to be matched upon. Let $n$ be the length of text $T$ where $T[1]$ is the first character and $T[n]$ is the last character of text $T$. Let $m$ be the length of the pattern such that $P[m]$ is the last character and $P[1]$ is the first character of pattern $P$.

\item Create and initialize the Shift Table. The two dimensional array, $ST$ (Shift Table), of size at most $(m+1)\times(m+1)$ will store the shift values for all pairs of characters. The $ST$ will be initialised with values of $m+2$.

\item Create and fill the $CON$ Table. As the index of the $ST$ is of type integer, we need to convert the pairs of characters into pairs of integers. This is done by defining an array of ASCII character set size called CON with each entry initialised to $0$.

\item For each character $c$ in the pattern the right most position (numbering from the right, starting with 1) is entered in the corresponding location in $CON$ ($CON[c]=$ right most position of c).

\item For every index $i$ starting at $m+1$, reading from right to left and finish at $1$, do steps 5-7.

	\item For each of characters $P[i]$ and $P[i-1]$ find the values of indices $a$ and $b$ from $CON[P[i-1]]$ and $CON[P[i]]$ respectively, in the $CON$ table.  If any of $P[i]$ or $P[i-1]$ does not exist use $0$ as the value for the substitute index for $a$ or $b$, respectively.

	\item In the shift table $ST$ at $(a, b)$, get the previously entered value $x$ from the table and obtain the value $y$ using the formula $$ y = m+2-i $$

	\item Get the minimum of the two values $x$ and $y$ and enter it back to the shift table $ST$ at $(a, b)$

\item Create the index $k$. Set a new variable $k=0$.

\item For every character $P[i]$ (index $i$) starting at $P[m]$ (index $m$) and finishing at $P[1]$ (index $1$), do step 10 
	
	\item Compare the characters $P[i]$ with $T[k + i]$. If they're not the same, skip to step 11. If they're the same, continue searching and once each pairs of characters are all the same, declare a match at $T[k+1]$ to $T[k+m]$ and stop the program.

\item Find the shift value $s$. The value of a shift for the pair $T [k +m+ 1]$ and $T [k +m+ 2]$ is $s = ST (CON[T[k + m+ 1]], CON[ T [k +m+ 2]])$. 
	
\item Add the new shift value to $k$. Set $k=k+s$.

\item Check the alignment window. Check if the new $k+m > n$. If it is true, declare that no match was found and stop the program, otherwise repeat steps 10-14. 

\end{enumerate}
\subsection{Example}

\section{Conclusions}

\end{document}  % This is where a 'short' article might terminate
